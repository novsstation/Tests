---
title: Problems for Refactoring
description: 
published: true
date: 2022-04-21T10:55:48.661Z
tags: 
editor: markdown
dateCreated: 2022-04-18T11:24:02.183Z
---

# Problems for refactoring

[original word doc](https://devexpress.sharepoint.com/:w:/s/devextreme/ERYw5bu-fgFMoyVyM__H5u4Ba9uxW1k58ZiOuHqh6Dl6_A?e=o2lMiK)

## Editing (Альяр + Коля) 

- Validation:  Валидатор не должен являться DOM компонентом. Это модель, которая должна храниться на уровне editData или еще где-то пока строка\ячейка находится в режиме редактирования. 
- EditorFactory: код для focusOverlay не должен быть частью editorFactory контроллера 
- Validation: отдельный validation state, изменяющийся при изменении editData => changes 
- Validation: убрать закладывание на undefined при вызове валидации. Сейчас это используется для идентификации значений в новой строке. Undefined считается нетронутой ячейков в новой строке, поэтому мы не валидим ее на фокусе, даже если в существующей строке у филда значение undefined. 
- Validation: think about adding an option to disable validating unmodified cells on focus. 
- Editing: если позвать saveEditData, когда пользователь редактирует ячейку, то результат не применится (cell, batch) 
- Editing: после saveEditData текущий эдитор не закрывается (cell) 
- Editing: проблема при редактировании во время сохранения в cell режиме https://supportcenter.devexpress.com/internal/ticket/details/T915055 
- Editing: удаление не работает, если есть несохраненная новая строка - https://supportcenter.devexpress.com/internal/ticket/details/T950444 
- EditorFactory: В `_getFocusedElement` методе содержится магический список селекторов, который нужно постоянно расширять, например в T959883. 
- Пофиксить в трилисте коллапс/экспанд нод в батче + убрать ресет для роу/формы  
- Изменение опции `editing.mode` в рантайме приводит к рефрешу. Стоило бы пересмотреть это и возможно не проводить рефреш в таком случае. 

## Keyboard Navigation (Коля + Константин) 

- Обновление состояния ячеек происходит только на клике или нажатии клавиш. Не хватает функционала для обновления состояния ячеек при эвенте focusin. 
- Нужен ли `_focusedView`? Если да, то нужно подумать о реализации навигации в других вьюхах грида. 
- При включенной focusedRow и фокусировки ячейки в RowsView по клавише Tab, если в ячейке есть интерактивный элемент то фокусится именно он. Если же focusedRow выключена, в такой же ситуации сначала фокусится ячейка, затем при повторном нажатии Tab, фокусится уже интерактивный элемент в ячейке. Нужно сделать консистентно во всех сценариях. 
- Из-за дефолтного навешивания tabindex на первую строку в rowsView, плохо получается управлять фокусом элементов, т.к. мы можем отбить фокусировку при нажатии/клике на тот или иной элемент через focusedCell/RowChanging, но происходит затем еще и браузерный фокус, который уже работает через другие ворота. Надо засинхронизить фокусировку элементов, путем реализации этого механизма через одни ворота. 
- С фиксированными колонками навигация за пределами rowsView работает через жопу. 
- Если включен keyboardNavigation.editOnKeyPress, то из редактируемой ячейки нельзя сразу уйти клавишами left/right. Нужно повторно нажимать эти клавиши. Первое нажатие выводит ячейку из режима редактирования, а последующее - переводит фокус на пред./след. ячейку. Стоит сделать мгновенный переходи на ячейку по первому нажатию клавиш. 
- Навигация не работает в хедерах, если включена виртуализация колонок. 
- Бесконечный вызов евента onCellClick так, как в процессе фокусы fire-ца click T934482 
- `_focusedCellPosition` нужен ли? Если да, то ,сделать дефолтное значение `_focusedCellPosition` консистентным с опциями грида focusedRowIndex/focusedColumnIndex (т.е. -1). Т.е. если ячейка не сфокушена, то `_focusedCellPosition` должен быть равен не пустому объекту, а  {  columnIndex: -1, rowIndex: -1} 
- https://trello.com/c/GXkm2ED5/5369-datagrid-treelist-focus-keyboardnavigation-tests-replace-pointereventsup-pointereventsdown-and-check-tests Что-то не то с тригерением dxpointerdown/dxpointerup ивентов. 
- Если командная колонка первая, то при переходе фокуса с хедера на rowsView, фокусится вся командная ячейка вместо первой командной кнопки.   

## Virtual Scrolling (Константин + Альяр + Коля) 

- Двойная загрузка на старте (https://trello.com/c/TnBoXC2o/3518-6-virtual-scrolling-loading-two-pages-on-start-problem)  
Возникла из-за текущего алгоритма подгрузки новой порции данных. Сейчас загрузка новой пейджи возникает, когда в результате скролла сменяется страница и из-за этого приходится грузить одну страницу вперед.  
Возможные решения: 
    - Изменить логику загрузки при старте. Грузить только одну страницу, а вторая чтобы грузилась, если первая не заполнила страницу. (сделано в 20.2 так, но хочется продолжить по 3.) 
    - Загружать 2 страницы одним запросом. Для этого придется изменять логику работы виртуального скроллинга с датасорсом. Сейчас датасорс за один раз грузит одну страницу. Для загрузки двух либо потребуется расширять состояние датасорса, либо загружать из сторов в обход состояния датасорса. 
    - Изменить алгоритм загрузки с постраничного на построчный и попиксельный. Потребуется заново написать виртуальный скроллинг. 
- Хак с откладыванием рендера при загрузке двух страниц. Сейчас если во вьюпорте видны 2 страницы, то рефреш загружает последовательно 2 страницы и только потом их рендерит, чтобы не было мельканий. Но для поддержки такого сценария написано достаточно много сложного и неочевидного кода.  
Возможные решения: 
    - Загружать 2 страницы одним запросом как в 1.1. 
    - Загружать 2 страницы по отдельности и обновлять только часть строк после одной загрузки. Потребуется сильно изменить виртуальный скроллинг и структуру айтемов, уйдя от массива в сторону мапа. 

- Наличие двух виртуальных скролл контроллеров со сложной логикой их взаимодействия.  
Возможные решения: 
    - Использовать один скролл контроллер или сделать отдельный виджет, который будет работать построчно и попиксельно. Для scrolling.mode 'virtual' можно будет написать отдельный хэлпер. 
- Глубокая интеграция текущего виртуального контроллера в датасорс адаптер. Это приводит к усложению логики и к сложности переиспользования.  
Возможные решения:
    - Изменить API виртуального скроллинга на более простое, возможно сделать отдельный виджет. Написать отдельный хэлпер, который будет заниматься интеграцией виртуального скроллинга в датасорса адаптер. 
    - В дополнение к 1. изменить логику работы адаптера с интеграции с датасорсами через ивенты на вызовы нужных методов, подмену состояния и тригерение ивентов. 
- Сложная работа с подсчетом кол-ва айтемов на странице и их коррекцией (itemsCount, correctCount). Эта логика связана с тем, что кол-во загружаемых айтемов отличается от кол-ва отображаемых айтемов, например при группировке.  
Возможные решения: 
    - Сделать так, чтобы виртуальный скроллинг работал по отображаемым айтемам и написать хелпер, который будет преобразовывать видимые индексы в дата индексы для определения того, какие данные загружать. 
- Сложная логика по формированию параметров change ивента (changeType: append, prepend, refresh, removeCount)  
Возможные решения: 
    - Переложить эту логику на виртуальный дом в реновированных виджетах. 
    - Использовать отдельный хэлпер/виджет, который будет определять параметры change ивента по старому и новому набору строк. Можно заиспользовать findChanges утилиту, которая используется для repaintChangesOnly. 
- repaintChangesOnly не работает корректно, если включены две виртуализации (mode и rowRenderingMode). Происходит частичный перерендер только первых пяти строк, а остальные всегда перерендеряются.  
Возможные решения: 
  - Использовать один виртуальный скролл контроллер или виджет как в 3.  Использовать findChanges как в 6.2. 
- Нет контроллируемости.  
Возможные решения: 
    - Добавить опции items, skip и getRows и метод createRowCache как в reactive,  
    - Добавить опцию data или items в виде объекта, а не массива, который можно экстендить для добавления айтемов и легче организовывать кэширование. Например `{ '10': {}, '11': {}, '12': {}, length: 100 }` И ивент onViewportUpdated или колбек requestRows, где можно получить индексы айтемов, которые нужно загрузить. 
- Перформанс. Сейчас пользователи периодически жалуются на перформанс виртуального скроллинга, особенно при сравнении с конкурентами.  
Возможные решения: 
    - Не выполнять расчеты ширин (updateDimensions) во время виртуализации/пейджирования. Сейчас есть логика, которая в определенных условиях откладывает обновление ширин во время скроллирования, но эта логика сложная и в идеале хотелось бы, чтобы размеры рассчитывались только на старте, как это делает ag-grid. Можно ввести новый режим обновления ширин только при первом показе. А перерасчет чтобы выполнялся через пункт в контекстном меню.  
    - Не выполнять расчеты высот во время виртуализации/пейджирования. Можно ввести опцию типа estimatedRowHeight, которую может задать, если пользователь уверен, что высоту строк не будут меняться, чтобы грид не выполнял взятия высот и не делал перерасчеты по ним. 
    - Переделать фиксированные колонки на стики, чтобы избежать двойного рендеринга. 
    - Включить по дефолту renderAsync 
    -  Задать фиксированные ширины командным колонкам, чтобы избежать расчета ширин по стилям и разметке. 
    -  Рендерить фейковую колонку в конце грида, чтобы избежать коррекции ширин, когда нет горизонтального скролла. 
    -  Отреновировать рендеринг грида. Когда рендеринг будет быстрее, виртуальный скроллинг будет работать быстрее и сейчас по большей части тормозит рендеринг. 
    -  Изменить разметку с таблицы на абсолютно спозиционированные дивы, как в ag-grid-е. Это можно сделать только после реновации. 
- Создать опцию по форсированию синхронного рендеринга - https://trello.com/c/HZBWENXN/977-datagrid-add-option-to-force-sync-async-virtual-scrolling 
- T906038: DataGrid - Rows are rendered incorrectly when the virtual scrolling and virtual row rendering mode are enabled and page size is less than the grid view port 
- LoadPanel скрывается раньше, чем отображаются данные. На это есть несколько комплексных багов. Также сейчас присутствует сложная логика по показу LoadPanel-и при наличии виртуального скроллинга. Хотелось бы ее упростить. 
- Не всем нравятся серые квадраты. Решение - ввести опцию. 

## Focused Row (Константин + Альяр) 

## Grouping 

- Выделить логику групинга в отдельную сущность и оторвать ее от конроллеров. 

## Sorting  

- Выделить логику сортинга в отдельную сущность и оторвать ее от конролееров. 

## Filtering 

- Выделить логику фильтеринга в отдельную сущность и оторвать ее от контроллеров. 

## Columns 

- Стоит избавится от синхронизации колонок, путем переноса хедера и футера в роуз вью и обратно. Нужно посмотреть в сторону sticky хедеров. 

## Push API 

- applyBatch - возможно стоит вынести объявление метода getErrorResult внуть applyBatch чтобы не тащить параметры типа isBatch и logError в insert, update и remove методы. 
