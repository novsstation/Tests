---
title: overview
description: 
published: true
date: 2022-04-18T11:25:08.027Z
tags: 
editor: markdown
dateCreated: 2022-04-18T11:25:05.420Z
---

# Что такое реновация?

## Необходимость

Есть несколько причин, по которым мы пришли к выводу о необходимости кардинальных изменений в нашем текущем подходе к разработке, а также переработке существующего кода. Основные из них:

* Две конкурирующие линейки продуктов - *Reactive* vs *Wrappers*
* Наши компоненты не являются нативными, это не нравится текущим пользователям и отталкивает новых
  * Пользователи, зачастую, даже не рассматривают наши линейки врапперов, а идут к нативным конкурентам или в *Reactive*
  * Текущие пользователи жалуются на сильные различия в *API* и *Lifecycle* компонентов
* Сложная кодовая база - "*JQuery Style*"
  * Монолитные компоненты
  * Императивный рендеринг
  * Сложный код
    * Большое количество багов
    * Сложность локализации проблем
    * Сложность масштабирования
    * Отсутствие модульности
* Устаревшие *QUnit* тесты
  * Долгие, сложные, нестабильные с неполным покрытием

Эти факторы заставили нас задуматься о том, как мы можем обновить кодовую базу, переписав ее, опираясь на современные подходы и новые требования качества.

## Концепция

Мы отвергли идею написания набора новых нативных компонентов под каждую платформу. У нас был опыт команды *Ractive*, который четко дал нам понять что на это нужно слишком много ресурсов (командой из 4-5 человек за 2 года мы не смогли повторить даже основные продукты *Grid*, *Scheduler*, *Charts*).

Мы решили разработать набор генераторов и деклараций с помощью которых будут описаны новые компоненты. По этим декларациям будут генерироваться нативные компоненты под необходимые нам платформы. Этот подход позволяет нам в будущем расширить список поддерживаемых платформ добавлением соответствующего генератора.

## Декларации

Декларации в нынешнем виде не так сильно отличаются от *react*-синтаксиса, используют его основные принципиальные подходы (*hooks*, *props*, *context*, *portals* и т.п.) с некоторыми дополнениями. Отличия вызваны тем, что одни и те же конструкции нужно применять для всех фреймворков.

Если бы мы писали на чистом *react*, нам пришлось бы очень много логики, которую сейчас реализуют генераторы, реализовывать вручную.

Подробно декларации описаны [тут](howto/howto.md)

## Генераторы

На данный момент мы реализуем четыре генератора, которые генерируют нативные компоненты из деклараций:

* *Pure js* генерирует компоненты для замены старых *Pure JS / JQuery*. В качестве виртуального дома под капотом используется [*Inferno*](https://github.com/infernojs/inferno). Выбор этого *vdom* обусловлен малым размером бандла и производительностью. До того как мы остановились на *Inferno* мы безуспешно использовали [*Preact*](https://preactjs.com/) и рассматривали возможность использования [*Svelte*](https://svelte.dev/);
* Angular;
* Vue;
* React.

## Принципы

1. **Обновление старой кодовой базы - уже успех.**
   Сам по себе рефакторинг и переход на современную компонентную модель и декларативный рендеринг имеет ценность. Код становится проще и понятнее, с меньшим количеством неявных зависимостей. В некоторых сценариях ожидается улучшение производительности. Также стоит отметить что первый этап реновации, который по сути является одним из этапов устранения накопленного технического долга, займет большую часть работы по реновации.

   Генерация нативных компонентов - лишь одна из составляющих реновации и когда мы достигнем успеха, это станет огромным подспорьем для маркетинга и продвижения продукта.
2. **Сохранение обратной совместимости**
   Наша задача сделать максимально плавный переход на реновированные компоненты, потому что большая часть дохода компании - это пользователи, продляющие подписку. Для этого мы максимально сохраняем обратную совместимость для наших существующих пользователей, внося критические изменения только в крайних случаях. При этом мы заранее предусматриваем возможные решения и собираем все *Breaking Changes* в специальный [список](breaking_changes.md).
3. **Реновируем по частям**
   Мы не стараемся реновировать все сразу. Придерживаясь покомпонентной модели обновления, мы стараемся обходить участки кода, не относящиеся к реновируемому компоненту или касающиеся только косвенно. К сожалению, есть объективные причины, по которым мы продолжаем использовать старый код в реновированных компонентах: сохранение обратной совместимости, например. В таких случаях каждый сквад самостоятельно решает, стоит ли им именно сейчас заняться переработкой проблемных мест, или более рационально будет использовать старые куски функциональности, к которым будет удобнее вернуться в будущем. Это издержки того, что мы пытаемся постепенно реновировать существующую кодовую базу, а не переписать ее заново. У нас есть примеры и переработки проблемных мест и эксплуатации старого кода. В некоторых случаях решение одновременно двух проблем может привести к еще большему количеству ошибок, мы предлагаем рационально подходить к этому процессу, последовательно решать задачи рефакторинга и реновации, разделять их по возможности. Но стоит помнить, что в конечном итоге нам необходимо переработать всю нашу кодовую базу, погасить, рано или поздно, все долги. Большой проблемой здесь является необходимость сохранения обратной совместимости, которая заставляет реновировать устаревшие, не всегда актуальные подходы, но это продиктовано нашей стратегией перехода на реновированные компоненты;
4. **Обкатка реновированных компонентов**
   Обновление компонента на реновированный - риск отдать пользователям несовместимую с предыдущей версию компонента. Для того, чтобы убедиться в том, что реновация прошла успешно, мы сохраняем код старого компонента на один релиз. Если мы получим критичный *feedback* - мы откатим компонент, если нет - выпилим старую версию из кодовой базы в следующем релизе.

## Планы

На данный момент мы убедились в принципиальной возможности реновации простых компонентов. Уже реновированны некоторые из них - *Button*, *Pager*, *CheckBox*. Теперь мы решили взять компонент посложнее - *Scheduler*. Все сквады работают над задачей реновации этого виджета. Срок окончания реновации - январь 2022 года. Этот, более сложный, компонент мы сможем предоставить пользователям для получения *feedback*'а, сможем предложить его пользователям *Reactive*. Заставить людей попробовать такой крупный и самостоятельный виджет как *Scheduler*, по нашему мнению, гораздо проще чем простенькие *Button* или *CheckBox*. Собрав отзывы, померив привлекательность для пользователей, мы будем принимать решение о дальнейших планах реновации.
