---
title: lifecircle
description: 
published: true
date: 2022-04-18T11:24:59.155Z
tags: 
editor: markdown
dateCreated: 2022-04-18T11:24:56.554Z
---

# Этапы реновации компонента

Реновация каждого компонента должна пройти через последовательность предопределенных процедур, список которых мы сформулировали исходя из нашего предыдущего опыта. Он не является строгим, и мы допускаем отступление от него при необходимости или удобстве, но рекомендуем сверять ход реновации с приведенным ниже жизненным циклом. Соблюдение этой формальности позволит избежать многих проблем и сэкономить время. Некоторые пункты являются обязательными, и без их выполнения мы не можем считать компонент реновированным.

## Анализ существующего кода

Перед тем как приступить непосредственно к реновации стоит проанализировать существующий код. При анализе обрати внимание на связанность кода, которую необходимо будет распутать, на перспективы разделения логики и рендера, на наличие внешних модулей, не относящихся к реновации компонента.

## Проведение необходимого рефакторинга

Зачастую, после анализа существующего кода, мы можем понять, что в том виде, в котором он есть, крайне тяжело его реновировать, и нам необходимо провести предварительный рефакторинг, который позволит более базболезненно перевести его на декларативный подход.

## Формирование *native API*

На данном этапе стоит задуматься о том, как изменится *API* компонента. Мы должны сделать его максимально близким к привычным способам взаимодействия с компонентами на конечных платформах. Принципы построения *API* для платформ категорически отличаются от текущих и обычно требуют переработки. Твое видение того, как будет выглядеть *API* компонента после реновации, стоит согласовать со сквадом *Platforms*.

## Проверка соответствия общим подходам

В процессе реновации мы сталкиваемся с проблемами, общими для всех компонентов или для множества компонентов. Находясь в поисках решения подобных проблем, нельзя забывать о единообразности решений. Для этого подобные решения мы собираем в [список](./known_issues.md). Ознакомься с пунктами, касающимися твоего компонента и учти при имплементации описанные там требования.

## Запись всех необходимых *Breaking Changes*

После формирования нового *API* станет более ясно на какие изменения нам придется пойти ради реновации. Мы реновируем исходя из принципа сохранения обратной совместимости, однако, это не всегда возможно. Все выявленные на данном этапе *Breaking Changes* стоит добавить в [список *Breaking Changes*](./breaking_changes.md) реновации. Этот список позволит *support*-инженерам быть готовыми к вопросам, которые нам будут задавать пользователи, и иметь на руках решения этих проблем. В процессе реновации, скорее всего, ты будешь сталкиваться и с другими изменениями, не связанными с *API*, которые необходимо внести. На всех этапах реновации стоит фиксировать их, обсуждать с командой *Platforms* и *support*-инженерами.

## Декомпозиция задачи

Продуманная декомпозиция такой объемной задачи как реновация - залог успеха. Не стоит браться за реновацию всего и сразу. Чем меньше итерации разработки и чем чаще мы достигаем контрольных точек - тем лучше мы контролируем процесс.

О чем стоит задуматься при разбиении на задачи:

* Какие проблемы мы можем решить до начала написания деклараций? Заблаговременный рефакторинг позволит убедиться, что произведенные изменения валидны на существующем массиве тестов - это проще и надежнее. Выдели подобный рефакторинг в отдельные задачи.
* Задумайся о структуре будущего компонента. Разбей его на под компоненты. Возможно можно выделить реновацию различных компонентов в разные обособленные таски.
* Если компонент достаточно крупный, возможно, мы можем реновировать его поэтапно, частями функциональности, и каждую часть можно выделить в отдельную задачу.
* Есть ли сложные алгоритмические или утилитные модули, которые не относятся непосредственно к компоненту. Возможно стоит выделить такие модули и исключить их реновирование в контексте реновации данного компонента?

## Планирование задачи

Запланируй каждую из задач, которые ты выделил ранее. Постарайся учесть все риски, которые могут возникнуть, наличие ресурсов на задачу.

Рекомендуется оценивать длительность задачи в "человеко-днях". Если на задачу выделено 10 дней, значит, ожидается, что чаще всего задача будет выполнена за 10 дней, несмотря на текучку. Можно использовать методику планирования работ [PERT](https://forpm.ru/%D0%BC%D0%B5%D1%82%D0%BE%D0%B4-pert/) - она поможет сделать оценку длительности задачи менее произвольной.

*Краткая формула*:
`
длительность задачи = (оптимистическая_оценка + 4*вероятная_оценка + пессимистическая_оцена) / 6
`

Рекомендуется в карточке задачи поддерживать актуальным чек-лист подзадач - это поможет быстро вспоминать конечную точку при смене контекста, а сокомандникам - оценивать прогресс для планирования зависимых задач.

На что стоит обратить внимание:

* Не собирается ли кто-то из твоей команды брать отпуск в это время?
* Нужно ли использовать в решении задачи новые технологии/подходы/инструменты, с которыми ты еще не знаком?
* Могут ли неожиданно появиться стопперы: нереализованная часть генератора, нереновированный внутренний компонент?
* Сможешь ли ты заниматься только этой задачей, или придется участвовать в разборе текучки?

## Написание декларации

Лишь сейчас, после проведения множества подготовительных работ, ты можешь начать переписывать старый код на декларации. Продуманный предварительный рефакторинг должен максимально облегчить эту задачу. Все технические нюансы написания деклараций описаны в этом [топике](howto/howto.md). Внимательно ознакомься с ним перед тем, как приступить. Декларации находятся в активной разработке, поэтому ты можешь сталкиваться с проблемами, не стесняйся задавать вопросы или предлагать изменения скваду *Platforms*.

[Этот](./howto/howto.md#сборка) топик поможет тебе разобраться в том как собирать исходники и запускать тестовое окружение (для *qunit* тестов).

## Написание тестов

По нашим правилам декларации должны быть на 100% покрыты *unit*-тестами. Правила написания этих тестов ты можешь прочесть [тут](./howto/howto.md#тестирование-компонентов).

## Поддержка тестов на старый компонент

Мы должны быть уверены, что реновированный компонент максимально близко повторяет старый компонент. Для того, чтобы убедиться в этом, нам необходимо добиться прохода всех старых тестов на реновированном компоненте. Для того, чтобы убедиться в сохранении внешнего вида компонента, мы советуем написать *testcafe* визуальные тесты на старые компоненты. После замены на реновированный эти тесты покажут малейшие отличия в *UI*.

## Проверка генерации нативных компонентов

На данный момент у нас есть пробел в тестировании нативных компонентов. Все тесты генерации присутствуют только на уровне генераторов (кроме *JQuery*), игнорируя конечный результат. Поэтому, для большей уверенности, мы советуем протестировать результаты генерации вручную.

## Проверка враперов

Перед выпуском необходимо убедиться что врапперы ([*devextreme-angular*](https://github.com/DevExpress/devextreme-angular), [*devextreme-vue*](https://github.com/DevExpress/devextreme-vue), [*devextreme-react*](https://github.com/DevExpress/devextreme-react)) продолжают корректно ("корректно" в данном случае означает "как раньше") работать используя реновированные компоненты под капотом. Хорошим маркером для этого являются *Widget Gallery* тесты, в которых присутствуют *layout*-тесты на врапперы. Тем не менее, не стоит пренебрегать ручным тестированием.

## Проверка перформанса

Мы должны быть уверены в том, что все производные от реновированного компонента (врапперы, нативные компоненты) не стали медленнее, как минимум. Для этого мы разработали [devextreme-bundle-maker](https://github.com/vconst/devextreme-bundle-maker), который поможет измерить производительность, память и размер бандлов виджетов во всех подходах и сравнить со старыми. Результаты тестов стоит обсудить со сквадом *Platforms*. Возможно, вместе вы сможете придумать способ получить еще большую производительность.

## Замена старого компонента на реновированный

На этом этапе в *npm* пакет *devextreme* должен попадать реновированный компонент вместо старого. Все тесты при этом должны проходить. Как это сделать смотри [тут](./howto/howto.md#jquery-1).

## Прохождение периода "обкатки"

В течении одного релиза мы сохраняем код старого компонента для возможности быстрого отката в случае получения критического *feedback*'а от пользователей.

## Удаление кода старого компонента

В случае успеха, удаляем код старого компонента в следующем после выпуска в продакшн релизе.
