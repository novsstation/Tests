---
title: known_issues
description: 
published: true
date: 2022-04-21T05:51:33.537Z
tags: 
editor: markdown
dateCreated: 2022-04-18T11:23:57.486Z
---

# Known issues

[Original word doc](https://devexpress.sharepoint.com/:w:/s/devextreme/ESVkO-NbFBtMmnvWRaHa17sBp44VZsOEacqoyaWeVd8v1A?e=wP5y4g)

## Scrolling 

### Скролирование не работает на тач экранах если тапнуть адаптиную строку. 

Текущее поведение из-за особенностей реализации фиксированных колонок. Сами фиксированные колонки и адаптивная строка рендерятся в отдельной таблице, в контейнере с overflow: "hidden". Из-за этого фиксированные колонки и адаптивная детальна строка не скролятся жестами. В будущем планиуем переписать фиксированные колонки на стики, тогда проблема автоматически пофиксится, а сейчас это by design. 

### Refresh в infinite скролинге загружает только первую пэйджу, в результате чего, скролинг не восстанавливается.  

Рекомендуем использовать в таком случае виртуальный скроллинг. 

## Virtual Scrolling 

### rowRenderingMode стоит использовать только при большом pageSize-е. 

При использовании с маленьким pageSize-ом (< 20) он будет вызывать только дополнительные тормоза без какого-либо профита, плюс возможны баги типа T906038 (DataGrid - Rows are rendered incorrectly when the virtual scrolling and virtual row rendering mode are enabled and page size is less than the grid view port) 

### rowIndex который передается в такие эвенты как onCellClick, может иметь неверные значения при виртуальном или инфинитном скролинге. 

Этот параметр хранится в опциях строки и не пересчитывается при подрендере новыx строк. Нужно использовать row.rowIndex вместо него. 

## Load Panel 

## Toolbar 

## Pager 

### Pager пропадает после рефреша, если состояние восстановлено с помощью stateStoring и pager.visible не задан 

По дефолту pager.visible выставлен в ‘auto’. Это значит, что пэйджер появится только если существует более одной пейджи. В случае восстановления состояния из state и значение пейджи не превышает 1, то пейджер не показывается. Нужно явно выставить pager.visible в true. 

### По дефолту, если пейджер был показан с одним датасорсом, он не пропадает после смены датасорса, даже если количество строк умещается на одну страницу.  

По дефолту pager.visible выставлен в ‘auto’. Если он при загрузки данных показался первый раз, то последующая смена датасорса не вызывает его скрытие. Нужно явно ставить visible в false. 

## Sorting 

### navigateToRow не работает, если отвортированы не ключевые колонки.

Мы добавляем в sort опции сортировку по ключу автоматом, если включена focusedRowEnabled. В противном случае сортировка не экстендится и метод работать не будет, если явно не отсортирована ключевая колонка. 

## Selection 

## Editing 

### Чекушки в булевской колонке сразу не меняют свое значение при клике, если ячейка в другой колонке находится в режиме редактирования (cell mode) 

Пока by design. Нужно включить repaintChangesOnly. 

### Удаление работает со второго клика если есть несохраненные добавляемые строки. 

Пока by design. Так сделано, чтобы пофиксить несколько багов с пропаданием данных. В будущем возможно удастся это пофиксить при рефакторинге редактирования. 

### В cell режиме, если в ячейке колонки с showEditorAlways == true поменять значение, затем кликнуть на ячейку в другой колонке где showEditorAlways == false, то фокус вернутся на предыдущую ячейку. 

Пока by design. Фокус со второго клика переходит куда нужно. 

### Если включен repaintChangesOnly, то каскадные лукапы не работают. Т.е. изменение одного лукапа не приводит к перерендеру контента второго. 

## Validation 

### Валидация срабатывает при клике на ячейку, даже если значение ячейки не изменено 

Так и задумано изначально. При вхождении в ячейку должна срабатывать валидация. В будущем можно улучшить, но пока так. 

## Adaptivity

### Если включен wordWrapEnabled и ширины колонок выставлены в процентах, то при ресайзе контейнера с меньшей шириной, могут появляться колонки которые были скрыты в контейнере с большей шириной.

Пока это бай дизайн, т.к. браузер пересчитывает ширины колонок из процентов не просто высчитыванием долей от ширины общего контейнера, как это делаем мы. Стоит пересмотреть логику скрытия колонок в адаптивности. 

## Filtering

## Filter Row 

### Ввод иероглифов принудительно завершается, даже без явной потери фокуса или нажатии Enter 

Пока это бай дизайн. Дело в том, что когда в гриде есть колонки с шириной 'auto', то при перезагрузке данных происходит синхронизация колонок. Процесс синхронизации заключается в переносе строк хедера и футера в rowsView. Чтобы браузер выставил ширины самостоятельно. В следствии чего фокус у эдитора в filterRow теряется. Затем мы возвращаем хедер и футер строки назад из rowsView, восстанавливая фокус у последнего сфокушенного эдитора, но в следствии потери фокуса, у эдитора ввод иероглифов уже продолжить нельзя. Мы планируем в будущем переделать хедеры на sticky и тогда этот изврат с переносом элементов между вью не нужен будет. Но на данный момент это просто так не поправить без значительных переделок. 

Как вариант, предложить кастомеру выставить valueChangeEvent у эдиторов лежащих в фильтр роу в "change", тогда у него значение будет применяться после нажатия Enter или потере фокуса. 

## Header Filter 

### Как кастомизить текста в headerFilter попапе? 

Использовать columns.customizeText колбек. Он вызывается как для ячеек таблицы, так и для айтемов в headerFilter-е. 

## Search

## FilterPanel 

## FilterBuilder 

### TextArea используемая в качестве эдитора не обновляет значение при потере фокуса 

TextArea сейчас не поддерживается вообще, мы на поддержку многострочных эдиторов не закладывались. 

### При смене операции с anyof на noneof и наоборот, значение сбрасывается. С операциями contains notcontains такого не просиходит. 

Сейчас кастомные операции не знают ничего друг о другие и их значения могут быть несовместимы между собой, поэтому для корректной работы во всех случаях мы сбрасываем значения при переключении между кастомными операциями.

## Column Fixing

### Если в темплейт ячейки вставляется контент, который расширяет высоту строки, то высоты строк в фиксированной таблице не синхронизятся 

Нужно создать CSS класс с фиксированной высотой и применить его через columns.cssClass. 

## Column Resizing

## Column Reordering

## Column Chooser

### Если оставить пару колонок и поресайзить, то после добавления еще одной колонки эта колонка скрывается.

При ресайзе колонки просчитывают свои ширыны в процентах. Т.е. сумма ширин видимых колонок 100%. Добавление следующей колонки приводит к выставлению ее ширины в auto. Как воркэраунд выставить columnMinWidth. 

## Master Detail

## Keyboard Navigation

### При нажатии Tab/Enter (enterKeyAction = "moveFocus"), ячейка в нередактированной колонке пропускается при фокусе 

Сделано специально, чтобы увеличить скоросить редактирования при клавиатурной навигации. 

### Вводимые символы могут теряться, если keyboardNavigation.editOnKeyPress включена 

У нас сейчас в реализации editOnKeyPress есть несколько таймаутов и от них не избавишься легким образом, только сильной переделкой фичи и то не факт. Поэтому это сейчас by design из-за особенностей реализации. Пользователю следует предложить использовать режим startEditAction: "click" или для колонки с баркодом выставить опции showEditorAlways: true и renderAsync: true. 

### При включенном keyboardNavigation.editOnKeyPress, если ячейка редактируется, то нажатие left\right не приводит к мгновенному переходу на пред./след. ячейку. 

Сейчас у нас позиция ячейки не пересчитывается, пока текущая ячейка не закроется. В будущем стоит это поправить, т.к. при навигации вверх/вниз, ячейка закрывается сразу. 
 
### Если командная колонка первая, то при переходе фокуса с хедера на rowsView, фокусится вся командная ячейка вместо первой командной кнопки.

Все из-за навешивания таб индекса на первую ячейку в rowsView. Более того, у нас отслеживания состояния ячейки происходит только уже при нажатой клавиши на сфокусированной ячейке. Повторное нажатие на Tab приведет к установке фокуса на нужную кнопку. Переделать это легко сейчас не получится. 

### Если дойти табом до последней ячейки в rows view, затем табом выйти из rows view в pager и поменять пейджу, то shift+tab возвращает фокус на первую ячейку в rows view. Ожидается возврат на последнюю.

Сейчас при клике за пределами rows view, мы намеренно скидываем состояние последней сфокусированной ячейки, чтобы предотвратить другого рода проблемы. Фиксить быстро это не получится без разлома других сценариев. Более того, если на новой пейдже количество айтемов будет меньше, нежели на предыдущей, надо будет еще нормализовывать состояние под текущее количество айтемов. 

## Grouping 

### Группировка и сортировка по одной колонке, а отображение значения группы из другой 

В этом случае нужно использовать groupCellTemplate. 

В общем случае в том числе и для удаленных данных доступ к другим полям лучше получать через group summary. Можно объявить в summary.groupItems айтем с колонкой на отображение и summaryType-ом ‘min’. В groupCellTemplate-е значение будет доступно через  cellInfo.data.summary[groupSummaryitemIndex]. Пример - https://codepen.io/vconst/pen/QWjYbRo 

При использовании локальных данных доступ к вложенным айтемам и значениям в колонках можно получить так: 

```js
var firstChildItem = (cellInfo.data.items || cellInfo.data.collapsedItems)[0]; 
```

### Когда группа заколлапшенна items поле равно null и заполненно поле collapseditems. Но следует учитывать, что collapseditems - это непубличное свойство. 

## Summary 

## Row Dragging 

### При драгинге не поддерживается рефшеш или экспанд/колапс строк.

Просто так это не фиксится, всплывают много нюансов, нужно ручками обновлять потроха сортабла. 
